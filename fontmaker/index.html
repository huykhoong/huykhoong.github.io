<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>Font Bitmap Pro (Upgraded)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/opentype.js@latest"></script>
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">

</head>
<body>
  <body>
    <!-- Add modal structure -->
    <div class="modal fade" id="helpModal" tabindex="-1">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title">H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
          </div>
          <div class="modal-body">
            <ol>
              <li>Ch·ªçn chi·ªÅu cao c·ªßa b·ªô font b·∫°n t√≠nh l√†m</li>
              <li>Upload file font TTF</li>
              <li>C√°c k√Ω t·ª± c∆° b·∫£n s·∫Ω t·ª± ƒë·ªông ƒë∆∞·ª£c t·∫°o k·ªÉ c·∫£ k√Ω t·ª± space</li>
              <li>*Th√™m k√Ω t·ª± ƒëang l·ªói nh∆∞ng m√¨nh ƒë√£ t·ª± l√†m full k√Ω t·ª± ti·∫øng Vi·ªát r·ªìi*</li>
              <li>Click v√†o k√Ω t·ª± ƒë·ªÉ ch·ªânh s·ª≠a bitmap</li>
              <li>ƒêi·ªÅu ch·ªânh ƒë·ªô r·ªông b·∫±ng n√∫t + v√† -, c√≥ th·ªÉ ƒëi·ªÅu ch·ªânh chi·ªÅu r·ªông c·ªßa kho·∫£ng space t·∫°i ƒë√¢y</li>
              <li>Nh·∫•n 'L∆∞u bitmap' sau khi ch·ªânh s·ª≠a (n·∫øu c√≥)</li>
              <li>Export ra file .h v√† s·ª≠ d·ª•ng</li>
            </ol>
            <hr>
            <small class="text-muted">¬© 2025 HuyKhong</small>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-primary" data-bs-dismiss="modal">ƒê√£ hi·ªÉu</button>
          </div>
        </div>
      </div>
    </div>
    
    
    
<div id="loadingOverlay"><div>ƒêang load font & render k√Ω t·ª±...</div></div>
<div class="container py-4">
  <div class="d-flex justify-content-between align-items-center mb-4">
    <h2 class="text-center mb-0">Font maker for Makefont</h2>
    <button type="button" class="btn btn-info" data-bs-toggle="modal" data-bs-target="#helpModal">
      <i class="bi bi-question-circle"></i> H∆∞·ªõng d·∫´n
    </button>
  </div>
  <div class="row mb-3">
    <div class="col-md-4">
      <label class="form-label">Upload Font (.ttf)</label>
      <input type="file" class="form-control" id="fontFile" accept=".ttf" />
    </div>
    <div class="col-md-4">
      <label class="form-label">Chi·ªÅu cao (px)</label>
      <input type="number" class="form-control" id="fontHeight" value="16" min="8" max="32" />
    </div>
    <div class="col-md-4">
      <label class="form-label">S·ªë pixel cho d·∫•u c√°ch (space)</label>
      <input type="number" class="form-control" id="spaceWidth" value="4" min="1" max="32" />
    </div> 
  </div>

  <div class="input-group mb-2">
    <input type="text" class="form-control" id="customCharInput" maxlength="2" placeholder="Nh·∫≠p k√Ω t·ª± t√πy ch·ªçn (VD: ‰∏≠, ‚ô•...)">
    <button class="btn btn-outline-primary" id="addCharBtn">Th√™m</button>
  </div> 

  <div class="mb-3">
    <label class="form-label">Danh s√°ch k√Ω t·ª±</label>
    <div id="charList" class="border p-2" style="height:120px; overflow-y:auto;"></div>
  </div>

  <div class="mb-3 d-flex align-items-center">
    <label class="form-label me-3">Chi·ªÅu r·ªông k√Ω t·ª±:</label>
    <button class="btn btn-outline-secondary btn-sm me-2" onclick="adjustWidth(-1)">-</button>
    <button class="btn btn-outline-secondary btn-sm" onclick="adjustWidth(1)">+</button>
  </div>

  <div class="mb-3">
    <label class="form-label">V·∫Ω bitmap</label>
    <div id="pixelGrid" class="pixel-grid border p-2"></div>
        <button class="btn btn-primary mt-2" id="saveBitmapBtn">üíæ L∆∞u bitmap hi·ªán t·∫°i</button>
  </div>

  <div class="mb-3 text-end">
    <div class="mb-3 d-flex justify-content-end align-items-center">
      <label class="form-label me-2"></label>
      <input type="text" class="form-control me-2" id="fontName" placeholder="V√≠ d·ª•: MyCustomFont" value="TenFont" style="width: auto;">
      <!-- <button class="btn btn-success me-2" id="exportBtn">Export .h</button> -->
      <button class="btn btn-warning" id="exportBtn">Xu·∫•t Font (.h)</button>
    </div>
  </div>
<div>
  <div class="mb-3">
    <label class="form-label">Preview vƒÉn b·∫£n</label>
    <textarea class="form-control" id="textInput" rows="2">L√∫c ·∫•y, ch√∫ h∆∞∆°u cao c·ªï b·∫ø ƒë·ª©a tr·∫ª ng·ªìi x√≠ch ƒëu tr√™n ph·ªë.</textarea>
    <div id="previewArea" class="border p-3 mt-2" style="min-height: 80px;"></div>
  </div>

  <textarea class="form-control mt-3" rows="10" id="outputCode" placeholder="M√£ .h s·∫Ω xu·∫•t hi·ªán ·ªü ƒë√¢y..."></textarea>
</div>

<script>
let currentChar = '';
let font = null;
let charBitmaps = {};
let fontName = '' ;

function createGrid(width, height) {
  const pixelGrid = document.getElementById('pixelGrid');
  pixelGrid.innerHTML = '';
  pixelGrid.style.gridTemplateColumns = `repeat(${width}, 16px)`;
  pixelGrid.style.gridTemplateRows = `repeat(${height}, 16px)`;
  for (let i = 0; i < width * height; i++) {
    const div = document.createElement('div');
    div.className = 'pixel';
    div.onclick = () => div.classList.toggle('active');
    pixelGrid.appendChild(div);
  }
}

document.getElementById('fontFile').addEventListener('change', (e) => {
  fontName = e.target.files[0].name.replace(/\.[^/.]+$/, "");
  cleanName = fontName.replace(/\.[^/.]+$/, '').replace(/[^a-zA-Z0-9]/g, '');
  const inputFontName = document.getElementById('fontName');
  if (cleanName &&  parseInt(document.getElementById('fontHeight').value)) {
    inputFontName.value = cleanName + parseInt(document.getElementById('fontHeight').value) + "pt";
  }
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (event) => {
    font = opentype.parse(event.target.result);
    loadCharacters();
  };
  reader.readAsArrayBuffer(file);
});

function loadCharacters() {
  const chars =
  'AƒÇ√ÇBCDƒêE√äFGHIJKLMNO√î∆†PQRSTU∆ØVWXYZ' + // ‚úÖ Ch·ªØ hoa kh√¥ng d·∫•u + ƒë·ªß √Ç √î
  '√Å√Ä·∫¢√É·∫†·∫Æ·∫∞·∫≤·∫¥·∫∂·∫§·∫¶·∫®·∫™·∫¨√â√à·∫∫·∫º·∫∏·∫æ·ªÄ·ªÇ·ªÑ·ªÜ√ç√å·ªàƒ®·ªä' +
  '√ì√í·ªé√ï·ªå·ªê·ªí·ªî·ªñ·ªò·ªö·ªú·ªû·ª†·ª¢√ö√ô·ª¶≈®·ª§·ª®·ª™·ª¨·ªÆ·ª∞√ù·ª≤·ª∂·ª∏·ª¥' + // ‚úÖ Ch·ªØ HOA c√≥ d·∫•u
  'abcdƒë√™√™fghijklmnopqrstuvwxyz√¢√¥∆°∆∞' + // ‚úÖ Ch·ªØ th∆∞·ªùng kh√¥ng d·∫•u + th√™m √¢ √¥
  '√°√†·∫£√£·∫°ƒÉ·∫Ø·∫±·∫≥·∫µ·∫∑√¢·∫•·∫ß·∫©·∫´·∫≠√©√®·∫ª·∫Ω·∫π√™·∫ø·ªÅ·ªÉ·ªÖ·ªá√≠√¨·ªâƒ©·ªã' +
  '√≥√≤·ªè√µ·ªç√¥·ªë·ªì·ªï·ªó·ªô∆°·ªõ·ªù·ªü·ª°·ª£√∫√π·ªß≈©·ª•∆∞·ª©·ª´·ª≠·ªØ·ª±√Ω·ª≥·ª∑·ªπ·ªµ' + // ‚úÖ Ch·ªØ th∆∞·ªùng c√≥ d·∫•u
  '0123456789.,:;!?()[]{}-+=*/'; 
  const charList = document.getElementById('charList');
  const loadingOverlay = document.getElementById('loadingOverlay');
  charList.innerHTML = '';
  charBitmaps = {};
  loadingOverlay.style.display = 'flex';
  setTimeout(() => {
    chars.split('').forEach(ch => {
      addCharToList(ch);
      selectChar(ch);
    });
    loadingOverlay.style.display = 'none';
    renderPreview();
  }, 100);
}

document.getElementById('addCharBtn').addEventListener('click', () => {
  const val = document.getElementById('customCharInput').value.trim();
  if (!val) return;
  for (const ch of val) {
    addCharToList(ch);
    selectChar(ch);
  }
  document.getElementById('customCharInput').value = '';
  renderPreview();
});

function addCharToList(ch) {
  const span = document.createElement('span');
  span.className = 'char-item';
  span.textContent = ch;
  span.onclick = () => selectChar(ch);
  document.getElementById('charList').appendChild(span);
}

function selectChar(ch) {
  currentChar = ch;
  const height = parseInt(document.getElementById('fontHeight').value);
  
  if (charBitmaps[ch]) {
    const data = charBitmaps[ch];
    createGrid(data.width, data.height);
    const pixels = [...document.getElementById('pixelGrid').children];
    data.bitmap.forEach((rowByte, row) => {
      for (let col = 0; col < data.width; col++) {
        const bit = (rowByte >> col) & 1;
        if (bit) pixels[row * data.width + col].classList.add('active');
      }
    });
    return;
  }

  if (ch === ' ') {
    const width = parseInt(document.getElementById('spaceWidth').value);
    const bitmap = new Array(height).fill(0);
    charBitmaps[ch] = { width, height, bitmap };
    createGrid(width, height);
    return;
  }

  // TƒÉng canvas height th√™m 25% ƒë·ªÉ ch·ª©a d·∫•u
  const canvas = document.createElement('canvas');
  canvas.width = height;
  canvas.height = Math.ceil(height * 1.25); // TƒÉng chi·ªÅu cao canvas
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  let hasGlyph = false;
  if (font) {
    const glyph = font.charToGlyph(ch);
    if (glyph && glyph.index > 0) {
      // D·ªãch chuy·ªÉn baseline xu·ªëng th√™m 25% height
      const baseline = Math.ceil(height * 0.95); // TƒÉng baseline
      const path = glyph.getPath(0, baseline, height);
      path.draw(ctx);
      hasGlyph = true;
    }
  }

  // L·∫•y chi·ªÅu cao th·ª±c c·ªßa canvas ƒë√£ tƒÉng
  const actualHeight = canvas.height;
  const imageData = ctx.getImageData(0, 0, height, actualHeight);
  let left = height - 1, right = 0;
  let foundPixel = false;
  
  // Qu√©t to√†n b·ªô canvas m·ªõi
  for (let y = 0; y < actualHeight; y++) {
    for (let x = 0; x < height; x++) {
      const idx = (y * height + x) * 4;
      if (imageData.data[idx + 3] > 128) {
        if (x < left) left = x;
        if (x > right) right = x;
        foundPixel = true;
      }
    }
  }

  const realWidth = foundPixel ? (right - left + 1) : 0;
  const finalWidth = realWidth + 1;
  const finalBitmap = [];

  // T·∫°o bitmap v·ªõi chi·ªÅu cao m·ªõi
  if (foundPixel) {
    for (let y = 0; y < actualHeight; y++) {
      let row = 0;
      for (let x = left; x <= right; x++) {
        const idx = (y * height + x) * 4;
        if (imageData.data[idx + 3] > 128) {
          row |= (1 << (x - left));
        }
      }
      finalBitmap.push(row);
    }
  } else {
    for (let y = 0; y < actualHeight; y++) {
      finalBitmap.push(0);
    }
  }

  // L∆∞u v·ªõi chi·ªÅu cao m·ªõi
  charBitmaps[ch] = { width: finalWidth, height: actualHeight, bitmap: finalBitmap };
  createGrid(finalWidth, actualHeight);

  const pixels = [...document.getElementById('pixelGrid').children];
  finalBitmap.forEach((rowByte, row) => {
    for (let col = 0; col < finalWidth; col++) {
      const bit = (rowByte >> (finalWidth - 1 - col)) & 1;
      if (bit) {
        pixels[row * finalWidth + col].classList.add('active');
      }
    }
  });

  renderPreview();
}

function adjustWidth(delta) {
  const data = charBitmaps[currentChar];
  if (!data) return;

  let { width, height, bitmap } = data;
  const newWidth = Math.max(1, Math.min(32, width + delta));
  const newBitmap = [];

  for (let row of bitmap) {
    if (delta > 0) {
      row <<= delta;
    } else {
      row >>= -delta;
    }
    row &= (1 << newWidth) - 1;
    newBitmap.push(row);
  }

  charBitmaps[currentChar] = { width: newWidth, height, bitmap: newBitmap };
  createGrid(newWidth, height);
  const pixels = [...document.getElementById('pixelGrid').children];
  newBitmap.forEach((rowByte, row) => {
    for (let col = 0; col < newWidth; col++) {
      const bit = (rowByte >> (newWidth - 1 - col)) & 1;
      if (bit) pixels[row * newWidth + col].classList.add('active');
    }
  });

  renderPreview();
}
const utf8Table = [
    0x00000020, // Space (index 0)
    0x0000C380, // √Ä (index 1)
    0x0000C381, // √Å (index 2)
    0x00E1BAA2, // ·∫¢ (index 3)
    0x0000C383, // √É (index 4)
    0x00E1BAA0, // ·∫† (index 5)
    0x0000C482, // ƒÇ (index 6)
    0x00E1BAB0, // ·∫∞ (index 7)
    0x00E1BAAE, // ·∫Æ (index 8)
    0x00E1BAB2, // ·∫≤ (index 9)
    0x00E1BAB4, // ·∫¥ (index 10)
    0x00E1BAB6, // ·∫∂ (index 11)
	0x0000C382, //√Ç
	0x00E1BAA6, //·∫¶
	0x00E1BAA4, //·∫§
	0x00E1BAA8, //·∫®
	0x00E1BAAA, //·∫™
	0x00E1BAAC, //·∫¨
	0x0000C490, //ƒê
	0x0000C388, //√à
	0x0000C389, //√â
	0x00E1BABA, //·∫∫
	0x00E1BABC, //·∫º
	0x00E1BAB8, //·∫∏
	0x0000C38A, //√ä
	0x00E1BB80, //·ªÄ
	0x00E1BABE, //·∫æ
	0x00E1BB82, //·ªÇ
	0x00E1BB84, //·ªÑ
	0x00E1BB86, //·ªÜ
	0x0000C38C, //√å
	0x0000C38D, //√ç
	0x00000020, // 
	0x00000021, //!
	0x00000022, //"
	0x00000023, //#
	0x00000024, //$
	0x00000025, //%
	0x00000026, //&
	0x00E28098, //‚Äò
	0x00000028, //(
	0x00000029, //)
	0x0000002A, //*
	0x0000002B, //+
	0x0000002C, //,
	0x00E28093, //‚Äì
	0x0000002E, //.
	0x0000002F, ///
	0x00000030, //0
	0x00000031, //1
	0x00000032, //2
	0x00000033, //3
	0x00000034, //4
	0x00000035, //5
	0x00000036, //6
	0x00000037, //7
	0x00000038, //8
	0x00000039, //9
	0x0000003A, //:
	0x0000003B, //;
	0x0000003C, //<
	0x0000003D, //=
	0x0000003E, //>
	0x0000003F, //?
	0x00000040, //@
	0x00000041, //A
	0x00000042, //B
	0x00000043, //C
	0x00000044, //D
	0x00000045, //E
	0x00000046, //F
	0x00000047, //G
	0x00000048, //H
	0x00000049, //I
	0x0000004A, //J
	0x0000004B, //K
	0x0000004C, //L
	0x0000004D, //M
	0x0000004E, //N
	0x0000004F, //O
	0x00000050, //P
	0x00000051, //Q
	0x00000052, //R
	0x00000053, //S
	0x00000054, //T
	0x00000055, //U
	0x00000056, //V
	0x00000057, //W
	0x00000058, //X
	0x00000059, //Y
	0x0000005A, //Z
	0x0000005B, //[
	0x0000005C, //
	0x0000005D, //]
	0x0000005E, //^
	0x0000005F, //_
	0x00000060, //`
	0x00000061, //a
	0x00000062, //b
	0x00000063, //c
	0x00000064, //d
	0x00000065, //e
	0x00000066, //f
	0x00000067, //g
	0x00000068, //h
	0x00000069, //i
	0x0000006A, //j
	0x0000006B, //k
	0x0000006C, //l
	0x0000006D, //m
	0x0000006E, //n
	0x0000006F, //o
	0x00000070, //p
	0x00000071, //q
	0x00000072, //r
	0x00000073, //s
	0x00000074, //t
	0x00000075, //u
	0x00000076, //v
	0x00000077, //w
	0x00000078, //x
	0x00000079, //y
	0x0000007A, //z
	0x0000007B, //{
	0x0000007C, //|
	0x0000007D, //}
	0x0000007E, //~
	0x00E1BB88, //·ªà
	0x0000C4A8, //ƒ®
	0x00E1BB8A, //·ªä
	0x0000C392, //√í
	0x0000C393, //√ì
	0x00E1BB8E, //·ªé
	0x0000C395, //√ï
	0x00E1BB8C, //·ªå
	0x0000C394, //√î
	0x00E1BB92, //·ªí
	0x00E1BB90, //·ªê
	0x00E1BB94, //·ªî
	0x00E1BB96, //·ªñ
	0x00E1BB98, //·ªò
	0x0000C6A0, //∆†
	0x00E1BB9C, //·ªú
	0x00E1BB9A, //·ªö
	0x00E1BB9E, //·ªû
	0x00E1BBA0, //·ª†
	0x00E1BBA2, //·ª¢
	0x0000C399, //√ô
	0x0000C39A, //√ö
	0x00E1BBA6, //·ª¶
	0x0000C5A8, //≈®
	0x00E1BBA4, //·ª§
	0x0000C6AF, //∆Ø
	0x00E1BBAA, //·ª™
	0x00E1BBA8, //·ª®
	0x00E1BBAC, //·ª¨
	0x00E1BBAE, //·ªÆ
	0x00E1BBB0, //·ª∞
	0x00E1BBB2, //·ª≤
	0x0000C39D, //√ù
	0x00E1BBB6, //·ª∂
	0x00E1BBB8, //·ª∏
	0x00E1BBB4, //·ª¥
	0x0000C3A0, //√†
	0x0000C3A1, //√°
	0x00E1BAA3, //·∫£
	0x0000C3A3, //√£
	0x00E1BAA1, //·∫°
	0x0000C483, //ƒÉ
	0x00E1BAB1, //·∫±
	0x00E1BAAF, //·∫Ø
	0x00E1BAB3, //·∫≥
	0x00E1BAB5, //·∫µ
	0x00E1BAB7, //·∫∑
	0x0000C3A2, //√¢
	0x00E1BAA7, //·∫ß
	0x00E1BAA5, //·∫•
	0x00E1BAA9, //·∫©
	0x00E1BAAB, //·∫´
	0x00E1BAAD, //·∫≠
	0x0000C491, //ƒë
	0x0000C3A8, //√®
	0x0000C3A9, //√©
	0x00E1BABB, //·∫ª
	0x00E1BABD, //·∫Ω
	0x00E1BAB9, //·∫π
	0x0000C3AA, //√™
	0x00E1BB81, //·ªÅ
	0x00E1BABF, //·∫ø
	0x00E1BB83, //·ªÉ
	0x00E1BB85, //·ªÖ
	0x00E1BB87, //·ªá
	0x0000C3AC, //√¨
	0x0000C3AD, //√≠
	0x00E1BB89, //·ªâ
	0x0000C4A9, //ƒ©
	0x00E1BB8B, //·ªã
	0x0000C3B2, //√≤
	0x0000C3B3, //√≥
	0x00E1BB8F, //·ªè
	0x0000C3B5, //√µ
	0x00E1BB8D, //·ªç
	0x0000C3B4, //√¥
	0x00E1BB93, //·ªì
	0x00E1BB91, //·ªë
	0x00E1BB95, //·ªï
	0x00E1BB97, //·ªó
	0x00E1BB99, //·ªô
	0x0000C6A1, //∆°
	0x00E1BB9D, //·ªù
	0x00E1BB9B, //·ªõ
	0x00E1BB9F, //·ªü
	0x00E1BBA1, //·ª°
	0x00E1BBA3, //·ª£
	0x0000C3B9, //√π
	0x0000C3BA, //√∫
	0x00E1BBA7, //·ªß
	0x0000C5A9, //≈©
	0x00E1BBA5, //·ª•
	0x0000C6B0, //∆∞
	0x00E1BBAB, //·ª´
	0x00E1BBA9, //·ª©
	0x00E1BBAD, //·ª≠
	0x00E1BBAF, //·ªØ
	0x00E1BBB1, //·ª±
	0x00E1BBB3, //·ª≥
	0x0000C3BD, //√Ω
	0x00E1BBB7, //·ª∑
	0x00E1BBB9, //·ªπ
	0x00E1BBB5, //·ªµ
	0x00E4BDA0, //‰Ω†
	0x00E5A5BD, //Â•Ω
	0x00E69C8B, //Êúã
	0x00E58F8B, //Âèã
	0x00E29DA4, //‚ù§
	0x0000C2B0, //¬∞
    //... (th√™m t·∫•t c·∫£ c√°c k√Ω t·ª± kh√°c theo ƒë√∫ng th·ª© t·ª± trong IOT47_UTF8.h)
  ];
  
  function reverseByteBits(byte) {
    let result = 0;
    for (let i = 0; i < 8; i++) {
      result <<= 1; // D·ªãch tr√°i k·∫øt qu·∫£
      if (byte & 1) { // N·∫øu bit cu·ªëi c·ªßa byte g·ªëc l√† 1
        result |= 1;  // Set bit cu·ªëi c·ªßa k·∫øt qu·∫£ l√† 1
      }
      byte >>= 1; // D·ªãch ph·∫£i byte g·ªëc ƒë·ªÉ x√©t bit ti·∫øp theo
    }
    return result;
  }

  document.getElementById('exportBtn').addEventListener('click', () => {
  const fontName = document.getElementById('fontName').value || "CustomFont";
  const fontHeight = parseInt(document.getElementById('fontHeight').value);
  const spaceWidth = parseInt(document.getElementById('spaceWidth').value);
  
  // T·∫°o b·∫£ng √°nh x·∫° k√Ω t·ª±
  const charToIndexMap = {};
  utf8Table.forEach((value, index) => {
    charToIndexMap[decodeUtf8(value)] = index;
  });

  // D·ªØ li·ªáu font - b·∫Øt ƒë·∫ßu v·ªõi mid line
  let fontData = [Math.floor(fontHeight * 0.75)];
  let charMap = Array(utf8Table.length).fill(0);

  // X·ª≠ l√Ω t·ª´ng k√Ω t·ª±
  Object.keys(charBitmaps).forEach(char => {
    if (!charToIndexMap.hasOwnProperty(char)) return;
    
    const index = charToIndexMap[char];
    let data = charBitmaps[char];
    
    // X·ª≠ l√Ω kho·∫£ng tr·∫Øng
    if (char === ' ') {
      data = {
        width: spaceWidth,
        height: fontHeight,
        bitmap: new Array(fontHeight).fill(0)
      };
    }
    
    const bytesPerRow = Math.ceil(data.width / 8);
    const startY = data.height < fontData[0] 
      ? fontData[0] - data.height 
      : 0;

    // L∆∞u v·ªã tr√≠ b·∫Øt ƒë·∫ßu
    charMap[index] = fontData.length + 4;

    fontData.push(
      data.width,  
      data.height,
      bytesPerRow,
      startY
    );

    // Th√™m d·ªØ li·ªáu bitmap v·ªõi x·ª≠ l√Ω ƒë·∫∑c bi·ªát cho k√Ω t·ª± h·∫πp
    for (let row = 0; row < data.height; row++) {
      let rowData = data.bitmap[row] || 0;
      
      // ƒê√≥ng g√≥i th√†nh bytes
      for (let b = 0; b < bytesPerRow; b++) {
      // L·∫•y byte th·ª© b (0 l√† LSB, 1 l√† byte ti·∫øp theo, ...)
      const originalByte = (rowData >> (8 * b)) & 0xFF;
      // *** S·ª¨A ƒê·ªîI: ƒê·∫£o ng∆∞·ª£c c√°c bit c·ªßa byte tr∆∞·ªõc khi push ***
      const reversedByte = reverseByteBits(originalByte);
      fontData.push(reversedByte); // Push byte ƒë√£ ƒë·∫£o ng∆∞·ª£c bit
    }
    }
  });

  // Ph·∫ßn t·∫°o file .h gi·ªØ nguy√™n nh∆∞ tr∆∞·ªõc...
  let output = `/*
  ${fontName}.h - Font ti·∫øng Vi·ªát UTF-8
  T·∫°o b·ªüi Font Bitmap Pro
*/

#ifndef _${fontName.toUpperCase()}_H_
#define _${fontName.toUpperCase()}_H_

#include <stdint.h>
#include <avr/pgmspace.h>
#include "MyFontMaker.h"

const uint8_t ${fontName}_name[] PROGMEM = {`;

  for (let i = 0; i < fontData.length; i++) {
    if (i % 16 === 0) output += '\n  ';
    output += `0x${fontData[i].toString(16).padStart(2, '0')},`;
  }
  output = output.slice(0, -1) + '\n};';

  output += `\n\nconst uint16_t ${fontName}_map[] PROGMEM = {`;
  for (let i = 0; i < charMap.length; i++) {
    if (i % 12 === 0) output += '\n  ';
    output += `0x${charMap[i].toString(16).padStart(4, '0')},`;
  }
  output = output.slice(0, -1) + '\n};';

  output += `\n\nconst MyFont_typedef ${fontName} PROGMEM = {
  ${fontName}_name,
  ${fontName}_map
};\n\n#endif`;

  // Xu·∫•t file
  const blob = new Blob([output], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${fontName}.h`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
});

// H√†m gi·∫£i m√£ UTF-8 (ƒë∆°n gi·∫£n)
function decodeUtf8(utf8Value) {
  if (utf8Value <= 0x7F) return String.fromCharCode(utf8Value);
  const bytes = [
    (utf8Value >> 24) & 0xFF,
    (utf8Value >> 16) & 0xFF,
    (utf8Value >> 8) & 0xFF,
    utf8Value & 0xFF
  ];
  let i = 0;
  while (i < 4 && bytes[i] === 0) i++;
  const validBytes = bytes.slice(i);
  return new TextDecoder().decode(new Uint8Array(validBytes));
}
  
  
// H√†m gi·∫£i m√£ UTF-8 (ƒë∆°n gi·∫£n)
function decodeUtf8(utf8Value) {
  if (utf8Value <= 0x7F) return String.fromCharCode(utf8Value);
  const bytes = [
    (utf8Value >> 24) & 0xFF,
    (utf8Value >> 16) & 0xFF,
    (utf8Value >> 8) & 0xFF,
    utf8Value & 0xFF
  ];
  let i = 0;
  while (i < 4 && bytes[i] === 0) i++;
  const validBytes = bytes.slice(i);
  return new TextDecoder().decode(new Uint8Array(validBytes));
}

document.getElementById('textInput').addEventListener('input', renderPreview);

function renderPreview() {
  const text = document.getElementById('textInput').value;
  const spaceWidth = parseInt(document.getElementById('spaceWidth').value);
  const previewArea = document.getElementById('previewArea');
  previewArea.innerHTML = '';

  for (const ch of text) {
    const data = charBitmaps[ch];
    if (!data) {
      if (ch === ' ') {
        const canvas = document.createElement('canvas');
        canvas.width = spaceWidth;
        canvas.height = parseInt(document.getElementById('fontHeight').value);
        previewArea.appendChild(canvas);
      }
      continue;
    }

    const canvas = document.createElement('canvas');
    canvas.width = data.width;
    canvas.height = data.height;
    const ctx = canvas.getContext('2d');

    data.bitmap.forEach((rowByte, y) => {
      for (let x = 0; x < data.width; x++) {
        if ((rowByte >> x) & 1) {
          ctx.fillRect(x, y, 1, 1); // v·∫Ω pixel theo chi·ªÅu ƒë√∫ng
        }
      }
    });

    previewArea.appendChild(canvas);
  }
}

document.getElementById("saveBitmapBtn").addEventListener("click", saveCurrentGrid);

function saveCurrentGrid() {
  const data = charBitmaps[currentChar];
  if (!data) return;

  const { width, height } = data;
  const pixels = [...document.getElementById('pixelGrid').children];
  const bitmap = [];

  for (let row = 0; row < height; row++) {
    let rowByte = 0;
    for (let col = 0; col < width; col++) {
      const i = row * width + col;
      if (pixels[i].classList.contains('active')) {
        rowByte |= (1 << col);  // ‚úÖ kh√¥ng b·ªã l·∫≠t
      }
    }
    bitmap.push(rowByte);
  }

  charBitmaps[currentChar].bitmap = bitmap;
  renderPreview();
}


document.addEventListener('DOMContentLoaded', function() {
  const helpModal = new bootstrap.Modal(document.getElementById('helpModal'));
  helpModal.show();
});
</script>

<p>¬© 2025 HuyKhong</p>
</body>
</html>
